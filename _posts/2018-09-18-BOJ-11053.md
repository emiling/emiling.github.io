---
title: BOJ 11053
categories: 1D1A
tags: ALG DP LIS
---

# Problem  
[Problem Number 11053](https://www.acmicpc.net/problem/11053)  
출처:  

LIS(Longest Increasing Subsequence)  
주어진 수열에서 가장 긴 증가하는 부분 수열을 구하시오.  

* * *

> DP로 풀면 O(N^2)의 시간 복잡도를 가지는데, O(NlogN)으로 풀 수 있는 방법이 있다고 한다. 나중에 찾아서 정리해야지.  

# Code  
~~~java
import java.util.Scanner;

public class Problem11053{

    public static int[] dp = new int[MAX_N];
    
    public static int findValue(int i) // O(n) * O(N)
    {
        if( i <= 0)
        {
            return 0;
        }
        if( i== 1)
        {
            return 1;
        }


        if(dp[i] >= 0)
        {
            return dp[i];
        }

        int answer = 0;

        for(int j = 1 ; j < i ; j ++)
        {   //j번째로 끝난 수열에서 이어붙여 보자 
            int len = 1 + findValue(j);
            answer = Math.max(answer, len);
        }

        dp[i] = answer;
        return answer;
    }

    // input 함수 생략
}
~~~

# Explanation  

여타 DP 문제와 같이 `findValue`는 첫번째에서 i번째 숫자까지 사용하고, i번째 숫자를 마지막으로 사용했을 때의 최대 LIS 길이를 구하는 함수이다.  

따라서 `dp` 배열에는 i번째 원소를 마지막으로 하는 LIS 길이가 들어가게 될 것이다.  

반복문을 돌면서 j번째로 끝난 수열에 1씩 해당 `findValue(j)`를 이여 붙이면서 answer값을 갱신시킨다.  


# etc  
R